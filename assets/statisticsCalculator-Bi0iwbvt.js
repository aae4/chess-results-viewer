import{f as C,a as A,b as q}from"./formatters-D4D2rNmP.js";import{C as G,h as W}from"./chess-f0FuLRjZ.js";function H({playerGames:u,ecoDatabase:f}){const o={colorStats:{white:{games:0,points:0,percent:0},black:{games:0,points:0,percent:0}},openingStats:[]};if(!u||u.length===0||!f)return o;const p={};return u.forEach(l=>{const i=A(q(l.result,l.color));if(i!==null&&(l.color==="w"?(o.colorStats.white.games++,o.colorStats.white.points+=i):l.color==="b"&&(o.colorStats.black.games++,o.colorStats.black.points+=i),l.pgn_moves))try{const m=new G;m.loadPgn(l.pgn_moves);const g=m.history();let c=null;for(let n=Math.min(g.length,20);n>0;n--){const h=W(g.slice(0,n));if(f[h]){c=f[h];break}}if(c){const n=c.e;p[n]||(p[n]={eco:n,name:c.n,count:0,points:0}),p[n].count++,p[n].points+=i}}catch{}}),o.colorStats.white.games>0&&(o.colorStats.white.percent=o.colorStats.white.points/o.colorStats.white.games*100),o.colorStats.black.games>0&&(o.colorStats.black.percent=o.colorStats.black.points/o.colorStats.black.games*100),o.openingStats=Object.values(p).sort((l,i)=>i.count-l.count||i.points-l.points),o}function J({participants:u,gamesForStats:f,standings:o,tournamentDetails:p,ecoDatabase:l}){if(!u?.length||!f?.length||!o?.length||!l)return null;const i=u.length,m=p?.rounds_count||0,g=Math.round(u.reduce((t,e)=>t+(e.rating||0),0)/u.length);let c=0,n=0,h=0,S={moves:1/0,game:null},v={moves:0,game:null},b=0,P=0,O=0,M=0;const d={},w={};f.forEach(t=>{const e=C(t.result);if(e==="1-0"?c++:e==="0-1"?n++:e==="½-½"&&(h++,w[t.white_player_id]=(w[t.white_player_id]||0)+1,w[t.black_player_id]=(w[t.black_player_id]||0)+1),t.pgn_moves)try{const s=new G;s.loadPgn(t.pgn_moves);const a=s.history(),y=Math.ceil(a.length/2);y>0&&(P++,b+=y,y<S.moves&&(S={moves:y,game:t}),y>v.moves&&(v={moves:y,game:t})),a.forEach(r=>{(r==="O-O"||r==="O-O-O")&&O++,r.includes("=")&&M++});let k=null;for(let r=Math.min(a.length,4);r>0;r--){const R=W(a.slice(0,r));if(l[R]){k=l[R];break}}if(k){const r=k.e;d[r]||(d[r]={eco:r,name:k.n,count:0,white:0,draw:0,black:0}),d[r].count++,e==="1-0"?d[r].white++:e==="0-1"?d[r].black++:e==="½-½"&&d[r].draw++}}catch{}});const _=c+n+h,E={whiteWins:c,blackWins:n,draws:h,totalGames:_,whiteWinPercent:_>0?Math.round(c/_*100):0,blackWinPercent:_>0?Math.round(n/_*100):0,drawPercent:_>0?Math.round(h/_*100):0},T=o.filter(t=>t.performance_rating&&t.rating_at_tournament).map(t=>({player:t,diff:t.performance_rating-t.rating_at_tournament})).sort((t,e)=>e.diff-t.diff)[0],j=o.map(t=>{const e=f.filter(a=>a.white_player_id===t.player_id||a.black_player_id===t.player_id).length,s=w[t.player_id]||0;return{player:{id:t.player_id,name:t.name},drawRate:e>0?s/e*100:100,playedGames:e,score:t.score,final_rank:t.final_rank}}).sort((t,e)=>t.drawRate!==e.drawRate?t.drawRate-e.drawRate:t.playedGames!==e.playedGames?e.playedGames-t.playedGames:t.score!==e.score?e.score-t.score:t.final_rank-e.final_rank)[0],I=o.filter(t=>!f.filter(s=>s.white_player_id===t.player_id||s.black_player_id===t.player_id).some(s=>{const a=C(s.result);return s.white_player_id===t.player_id&&a==="0-1"||s.black_player_id===t.player_id&&a==="1-0"})),x=Object.values(d).sort((t,e)=>e.count-t.count||t.name.localeCompare(e.name)).slice(0,10);return{totalPlayers:i,totalRounds:m,averageRating:g,resultDistribution:E,shortestGame:S,longestGame:v,averageMoveCount:P>0?Math.round(b/P):0,biggestOverperformer:T,undefeatedPlayers:I,mostDecisivePlayer:j,topOpenings:x,totalCastles:O,totalPromotions:M}}export{H as a,J as c};
